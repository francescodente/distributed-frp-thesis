@misc{scala-lang-spec,
    title        = {Scala 2.13 Language Specification},
    key          = {Scala 2.13 Language Specification},
    howpublished = {\url{https://www.scala-lang.org/files/archive/spec/2.13/}},
    note         = {Accessed: 2023-02-21}
}

@misc{scala3-reference,
    title        = {Scala 3 Reference},
    key          = {Scala 3 Reference},
    howpublished = {\url{https://docs.scala-lang.org/scala3/reference/}},
    note         = {Accessed: 2023-02-21}
}

@misc{new-in-scala-3,
    title        = {New in Scala 3},
    key          = {New in Scala 3},
    howpublished = {\url{https://docs.scala-lang.org/scala3/new-in-scala3.html}},
    note         = {Accessed: 2023-02-22}
}

@book{blackheath2016functional,
    title        = {Functional Reactive Programming},
    author       = {Blackheath, S.},
    isbn         = {9781638353416},
    url          = {https://books.google.it/books?id=mTkzEAAAQBAJ},
    year         = {2016},
    publisher    = {Manning}
}

@article{bainomugisha2013survey,
    author       = {Bainomugisha, Engineer and Carreton, Andoni Lombide and Cutsem, Tom van and Mostinckx, Stijn and Meuter, Wolfgang de},
    title        = {A Survey on Reactive Programming},
    year         = {2013},
    issue_date   = {August 2013},
    publisher    = {Association for Computing Machinery},
    address      = {New York, NY, USA},
    volume       = {45},
    number       = {4},
    issn         = {0360-0300},
    url          = {https://doi.org/10.1145/2501654.2501666},
    doi          = {10.1145/2501654.2501666},
    abstract     = {Reactive programming has recently gained popularity as a paradigm that is well-suited for developing event-driven and interactive applications. It facilitates the development of such applications by providing abstractions to express time-varying values and automatically managing dependencies between such values. A number of approaches have been recently proposed embedded in various languages such as Haskell, Scheme, JavaScript, Java, .NET, etc. This survey describes and provides a taxonomy of existing reactive programming approaches along six axes: representation of time-varying values, evaluation model, lifting operations, multidirectionality, glitch avoidance, and support for distribution. From this taxonomy, we observe that there are still open challenges in the field of reactive programming. For instance, multidirectionality is supported only by a small number of languages, which do not automatically track dependencies between time-varying values. Similarly, glitch avoidance, which is subtle in reactive programs, cannot be ensured in distributed reactive programs using the current techniques.},
    journal      = {ACM Comput. Surv.},
    month        = {aug},
    articleno    = {52},
    numpages     = {34},
    keywords     = {reactive systems, interactive applications, functional reactive programming, event-driven applications, dataflow programming, Reactive programming}
}

@article{VIROLI2019100486,
    title        = {From distributed coordination to field calculus and aggregate computing},
    journal      = {Journal of Logical and Algebraic Methods in Programming},
    volume       = {109},
    pages        = {100486},
    year         = {2019},
    issn         = {2352-2208},
    doi          = {https://doi.org/10.1016/j.jlamp.2019.100486},
    url          = {https://www.sciencedirect.com/science/article/pii/S235222081930032X},
    author       = {Mirko Viroli and Jacob Beal and Ferruccio Damiani and Giorgio Audrito and Roberto Casadei and Danilo Pianini},
    keywords     = {Distributed systems, Aggregate computing, Field calculus, Spatial computing},
    abstract     = {Aggregate computing is an emerging approach to the engineering of complex coordination for distributed systems, based on viewing system interactions in terms of information propagating through collectives of devices, rather than in terms of individual devices and their interaction with their peers and environment. The foundation of this approach is the distillation of a number of prior approaches, both formal and pragmatic, proposed under the umbrella of field-based coordination, and culminating into the field calculus, a universal functional programming model for the specification and composition of collective behaviours with equivalent local and aggregate semantics. This foundation has been elaborated into a layered approach to engineering coordination of complex distributed systems, building up to pragmatic applications through intermediate layers encompassing reusable libraries of program components. Furthermore, some of these components are formally shown to satisfy formal properties like self-stabilisation, which transfer to whole application services by functional composition. In this survey, we trace the development and antecedents of field calculus, review the field calculus itself and the current state of aggregate computing theory and practice, and discuss a roadmap of current research directions with implications for the development of a broad range of distributed systems.}
}

@article{10.1145/3177774,
    author       = {Viroli, Mirko and Audrito, Giorgio and Beal, Jacob and Damiani, Ferruccio and Pianini, Danilo},
    title        = {Engineering Resilient Collective Adaptive Systems by Self-Stabilisation},
    year         = {2018},
    issue_date   = {April 2018},
    publisher    = {Association for Computing Machinery},
    address      = {New York, NY, USA},
    volume       = {28},
    number       = {2},
    issn         = {1049-3301},
    url          = {https://doi.org/10.1145/3177774},
    doi          = {10.1145/3177774},
    abstract     = {Collective adaptive systems are an emerging class of networked computational systems particularly suited for application domains such as smart cities, complex sensor networks, and the Internet of Things. These systems tend to feature large-scale, heterogeneity of communication model (including opportunistic peer-to-peer wireless interaction) and require inherent self-adaptiveness properties to address unforeseen changes in operating conditions. In this context, it is extremely difficult (if not seemingly intractable) to engineer reusable pieces of distributed behaviour to make them provably correct and smoothly composable.Building on the field calculus, a computational model (and associated toolchain) capturing the notion of aggregate network-level computation, we address this problem with an engineering methodology coupling formal theory and computer simulation. On the one hand, functional properties are addressed by identifying the largest-to-date field calculus fragment generating self-stabilising behaviour, guaranteed to eventually attain a correct and stable final state despite any transient perturbation in state or topology and including highly reusable building blocks for information spreading, aggregation, and time evolution. On the other hand, dynamical properties are addressed by simulation, empirically evaluating the different performances that can be obtained by switching between implementations of building blocks with provably equivalent functional properties. Overall, our methodology sheds light on how to identify core building blocks of collective behaviour and how to select implementations that improve system performance while leaving overall system function and resiliency properties unchanged.},
    journal      = {ACM Trans. Model. Comput. Simul.},
    month        = {mar},
    articleno    = {16},
    numpages     = {28},
    keywords     = {simulation and modeling, Aggregate computing, self-stabilisation, field calculus, distributed algorithms, collective adaptive systems}
}

@inproceedings{10.1145/2957319.2957372,
    author       = {Casadei, Roberto and Viroli, Mirko},
    title        = {Towards Aggregate Programming in Scala},
    year         = {2016},
    isbn         = {9781450347754},
    publisher    = {Association for Computing Machinery},
    address      = {New York, NY, USA},
    url          = {https://doi.org/10.1145/2957319.2957372},
    doi          = {10.1145/2957319.2957372},
    abstract     = {Recent works in the context of large-scale adaptive systems, such as those for the Internet of Things (IoT) scenario, promote aggregate programming [3], a development approach for distributed systems in which one programs the aggregate of computational devices instead of individual ones. This makes the resulting behaviour highly insensitive to network size, density, and topology, and as such, intrinsically robust to failures and changes to working conditions (e.g., location of computational load, communication technology, and computational infrastructure).In this paper we are concerned with how this approach can impact mainstream software development, and hence outline a Scala-based support of aggregate programming, leveraging Scala advanced type system, DSL support, and actors mechanisms.},
    booktitle    = {First Workshop on Programming Models and Languages for Distributed Computing},
    articleno    = {5},
    numpages     = {7},
    keywords     = {aggregate programming, DSL, complex adaptive systems, distributed platform, Scala},
    location     = {Rome, Italy},
    series       = {PMLDC '16}
}

@misc{scafi-docs,
    title        = {Scafi documentation},
    key          = {Scafi documentation},
    howpublished = {\url{https://scafi.github.io/}},
    note         = {Accessed: 2023-02-26}
}

@InProceedings{10.1007/3-540-45337-7_17,
    author       = {Ernst, Erik},
    editor       = {Knudsen, J{\o}rgen Lindskov},
    title        = {Family Polymorphism},
    booktitle    = {ECOOP 2001 --- Object-Oriented Programming},
    year         = {2001},
    publisher    = {Springer Berlin Heidelberg},
    address      = {Berlin, Heidelberg},
    pages        = {303--326},
    abstract     = {This paper takes polymorphism to the multi-object level. Traditional inheritance, polymorphism, and late binding interact nicely to provide both flexibility and safety --- when a method is invoked on an object via a polymorphic reference, late binding ensures that we get the appropriate implementation of that method for the actual object. We are granted the flexibility of using different kinds of objects and different method implementations, and we are guaranteed the safety of the combination. Nested classes, polymorphism, and late binding of nested classes interact similarly to provide both safety and flexibility at the level of multi-object systems. We are granted the flexibility of using different families of kinds of objects, and we are guaranteed the safety of the combination. This paper highlights the inability of traditional polymorphism to handle multiple objects, and presents family polymorphism as a way to overcome this problem. Family polymorphism has been implemented in the programming language gbeta, a generalized version of Beta, and the source code of this implementation is available under GPL.1},
    isbn         = {978-3-540-45337-6}
}

@article{10.1145/2591013,
    author       = {Odersky, Martin and Rompf, Tiark},
    title        = {Unifying Functional and Object-Oriented Programming with Scala},
    year         = {2014},
    issue_date   = {April 2014},
    publisher    = {Association for Computing Machinery},
    address      = {New York, NY, USA},
    volume       = {57},
    number       = {4},
    issn         = {0001-0782},
    url          = {https://doi.org/10.1145/2591013},
    doi          = {10.1145/2591013},
    abstract     = {Scala unifies traditionally disparate programming-language philosophies to develop new components and component systems.},
    journal      = {Commun. ACM},
    month        = {apr},
    pages        = {76-86},
    numpages     = {11}
}

@article{pianini2013chemical,
    author       = {Pianini, Danilo and Montagna, Sara and Viroli, Mirko},
    year         = {2013},
    month        = {01},
    pages        = {},
    title        = {Chemical-oriented simulation of computational systems with ALCHEMIST},
    volume       = {7},
    journal      = {Journal of Simulation},
    doi          = {10.1057/jos.2012.27}
}

@article{CASADEI2022101248,
    title        = {ScaFi: A Scala DSL and Toolkit for Aggregate Programming},
    journal      = {SoftwareX},
    volume       = {20},
    pages        = {101248},
    year         = {2022},
    issn         = {2352-7110},
    doi          = {https://doi.org/10.1016/j.softx.2022.101248},
    url          = {https://www.sciencedirect.com/science/article/pii/S2352711022001662},
    author       = {Roberto Casadei and Mirko Viroli and Gianluca Aguzzi and Danilo Pianini},
    keywords     = {Aggregate programming, Computational fields, Macro-level programming, Distributed computing, Scala toolkit},
    abstract     = {Supported by current socio-scientific trends, programming the global behaviour of whole computational collectives makes for great opportunities, but also significant challenges. Recently, aggregate computing has emerged as a prominent paradigm for so-called collective adaptive systems programming. To shorten the gap between such research endeavours and mainstream software development and engineering, we present ScaFi, a Scala toolkit providing an internal domain-specific language, libraries, a simulation environment, and runtime support for practical aggregate computing systems development.}
}

@InProceedings{10.1007/978-3-030-50029-0_13,
    author="Pianini, Danilo
    and Mariani, Stefano
    and Viroli, Mirko
    and Zambonelli, Franco",
    editor="Bliudze, Simon
    and Bocchi, Laura",
    title="Time-Fluid Field-Based Coordination",
    booktitle="Coordination Models and Languages",
    year="2020",
    publisher="Springer International Publishing",
    address="Cham",
    pages="193--210",
    abstract="Emerging application scenarios, such as cyber-physical systems (CPSs), the Internet of Things (IoT), and edge computing, call for coordination approaches addressing openness, self-adaptation, heterogeneity, and deployment agnosticism. Field-based coordination is one such approach, promoting the idea of programming system coordination declaratively from a global perspective, in terms of functional manipulation and evolution in ``space and time'' of distributed data structures, called fields. More specifically, regarding time, in field-based coordination it is assumed that local activities in each device, called computational rounds, are regulated by a fixed clock, typically, a fair and unsynchronized distributed scheduler. In this work, we challenge this assumption, and propose an alternative approach where the round execution scheduling is naturally programmed along with the usual coordination specification, namely, in terms of a field of causal relations dictating what is the notion of causality (why and when a round has to be locally scheduled) and how it should change across time and space. This abstraction over the traditional view on global time allows us to express what we call ``time-fluid'' coordination, where causality can be finely tuned to select the event triggers to react to, up to to achieve improved balance between performance (system reactivity) and cost (usage of computational resources). We propose an implementation in the aggregate computing framework, and evaluate via simulation on a case study.",
    isbn="978-3-030-50029-0"
}

