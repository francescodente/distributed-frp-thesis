@misc{scala-lang-spec,
    title        = {Scala 2.13 Language Specification},
    key          = {Scala 2.13 Language Specification},
    howpublished = {\url{https://www.scala-lang.org/files/archive/spec/2.13/}},
    note         = {Accessed: 2023-02-21}
}

@misc{scala3-reference,
    title        = {Scala 3 Reference},
    key          = {Scala 3 Reference},
    howpublished = {\url{https://docs.scala-lang.org/scala3/reference/}},
    note         = {Accessed: 2023-02-21}
}

@misc{new-in-scala-3,
    title        = {New in Scala 3},
    key          = {New in Scala 3},
    howpublished = {\url{https://docs.scala-lang.org/scala3/new-in-scala3.html}},
    note         = {Accessed: 2023-02-22}
}

@book{blackheath2016functional,
    title        = {Functional Reactive Programming},
    author       = {Blackheath, S.},
    isbn         = {9781638353416},
    url          = {https://books.google.it/books?id=mTkzEAAAQBAJ},
    year         = {2016},
    publisher    = {Manning}
}

@article{bainomugisha2013survey,
    author       = {Bainomugisha, Engineer and Carreton, Andoni Lombide and Cutsem, Tom van and Mostinckx, Stijn and Meuter, Wolfgang de},
    title        = {A Survey on Reactive Programming},
    year         = {2013},
    issue_date   = {August 2013},
    publisher    = {Association for Computing Machinery},
    address      = {New York, NY, USA},
    volume       = {45},
    number       = {4},
    issn         = {0360-0300},
    url          = {https://doi.org/10.1145/2501654.2501666},
    doi          = {10.1145/2501654.2501666},
    abstract     = {Reactive programming has recently gained popularity as a paradigm that is well-suited for developing event-driven and interactive applications. It facilitates the development of such applications by providing abstractions to express time-varying values and automatically managing dependencies between such values. A number of approaches have been recently proposed embedded in various languages such as Haskell, Scheme, JavaScript, Java, .NET, etc. This survey describes and provides a taxonomy of existing reactive programming approaches along six axes: representation of time-varying values, evaluation model, lifting operations, multidirectionality, glitch avoidance, and support for distribution. From this taxonomy, we observe that there are still open challenges in the field of reactive programming. For instance, multidirectionality is supported only by a small number of languages, which do not automatically track dependencies between time-varying values. Similarly, glitch avoidance, which is subtle in reactive programs, cannot be ensured in distributed reactive programs using the current techniques.},
    journal      = {ACM Comput. Surv.},
    month        = {aug},
    articleno    = {52},
    numpages     = {34},
    keywords     = {reactive systems, interactive applications, functional reactive programming, event-driven applications, dataflow programming, Reactive programming}
}

@article{VIROLI2019100486,
    title        = {From distributed coordination to field calculus and aggregate computing},
    journal      = {Journal of Logical and Algebraic Methods in Programming},
    volume       = {109},
    pages        = {100486},
    year         = {2019},
    issn         = {2352-2208},
    doi          = {https://doi.org/10.1016/j.jlamp.2019.100486},
    url          = {https://www.sciencedirect.com/science/article/pii/S235222081930032X},
    author       = {Mirko Viroli and Jacob Beal and Ferruccio Damiani and Giorgio Audrito and Roberto Casadei and Danilo Pianini},
    keywords     = {Distributed systems, Aggregate computing, Field calculus, Spatial computing},
    abstract     = {Aggregate computing is an emerging approach to the engineering of complex coordination for distributed systems, based on viewing system interactions in terms of information propagating through collectives of devices, rather than in terms of individual devices and their interaction with their peers and environment. The foundation of this approach is the distillation of a number of prior approaches, both formal and pragmatic, proposed under the umbrella of field-based coordination, and culminating into the field calculus, a universal functional programming model for the specification and composition of collective behaviours with equivalent local and aggregate semantics. This foundation has been elaborated into a layered approach to engineering coordination of complex distributed systems, building up to pragmatic applications through intermediate layers encompassing reusable libraries of program components. Furthermore, some of these components are formally shown to satisfy formal properties like self-stabilisation, which transfer to whole application services by functional composition. In this survey, we trace the development and antecedents of field calculus, review the field calculus itself and the current state of aggregate computing theory and practice, and discuss a roadmap of current research directions with implications for the development of a broad range of distributed systems.}
}

@article{10.1145/3177774,
    author       = {Viroli, Mirko and Audrito, Giorgio and Beal, Jacob and Damiani, Ferruccio and Pianini, Danilo},
    title        = {Engineering Resilient Collective Adaptive Systems by Self-Stabilisation},
    year         = {2018},
    issue_date   = {April 2018},
    publisher    = {Association for Computing Machinery},
    address      = {New York, NY, USA},
    volume       = {28},
    number       = {2},
    issn         = {1049-3301},
    url          = {https://doi.org/10.1145/3177774},
    doi          = {10.1145/3177774},
    abstract     = {Collective adaptive systems are an emerging class of networked computational systems particularly suited for application domains such as smart cities, complex sensor networks, and the Internet of Things. These systems tend to feature large-scale, heterogeneity of communication model (including opportunistic peer-to-peer wireless interaction) and require inherent self-adaptiveness properties to address unforeseen changes in operating conditions. In this context, it is extremely difficult (if not seemingly intractable) to engineer reusable pieces of distributed behaviour to make them provably correct and smoothly composable.Building on the field calculus, a computational model (and associated toolchain) capturing the notion of aggregate network-level computation, we address this problem with an engineering methodology coupling formal theory and computer simulation. On the one hand, functional properties are addressed by identifying the largest-to-date field calculus fragment generating self-stabilising behaviour, guaranteed to eventually attain a correct and stable final state despite any transient perturbation in state or topology and including highly reusable building blocks for information spreading, aggregation, and time evolution. On the other hand, dynamical properties are addressed by simulation, empirically evaluating the different performances that can be obtained by switching between implementations of building blocks with provably equivalent functional properties. Overall, our methodology sheds light on how to identify core building blocks of collective behaviour and how to select implementations that improve system performance while leaving overall system function and resiliency properties unchanged.},
    journal      = {ACM Trans. Model. Comput. Simul.},
    month        = {mar},
    articleno    = {16},
    numpages     = {28},
    keywords     = {simulation and modeling, Aggregate computing, self-stabilisation, field calculus, distributed algorithms, collective adaptive systems}
}
